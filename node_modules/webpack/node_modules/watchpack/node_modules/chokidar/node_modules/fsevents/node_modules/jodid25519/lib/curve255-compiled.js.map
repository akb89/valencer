{"version":3,"sources":["curve255.js"],"names":[],"mappings":"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","file":"curve255-compiled.js","sourcesContent":["\"use strict\";\n/**\n * @fileOverview\n * Core operations on curve 25519 required for the higher level modules.\n */\n\n/*\n * Copyright (c) 2007, 2013, 2014 Michele Bini\n * Copyright (c) 2014 Mega Limited\n * under the MIT License.\n *\n * Authors: Guy K. Kloss, Michele Bini\n *\n * You should have received a copy of the license along with this program.\n */\n\nvar core = require('./core');\nvar utils = require('./utils');\n\n    /**\n     * @exports jodid25519/curve255\n     * Legacy compatibility module for Michele Bini's previous curve255.js.\n     *\n     * @description\n     * Legacy compatibility module for Michele Bini's previous curve255.js.\n     *\n     * <p>\n     * This code presents an API with all key formats as previously available\n     * from Michele Bini's curve255.js implementation.\n     * </p>\n     */\n    var ns = {};\n\n    function curve25519_raw(f, c) {\n        var a, x_1, q;\n\n        x_1 = c;\n        a = core.dbl(x_1, core.ONE());\n        q = [x_1, core.ONE()];\n\n        var n = 255;\n\n        while (core.getbit(f, n) == 0) {\n            n--;\n            // For correct constant-time operation, bit 255 should always be\n            // set to 1 so the following 'while' loop is never entered.\n            if (n < 0) {\n                return core.ZERO();\n            }\n        }\n        n--;\n\n        var aq = [a, q];\n\n        while (n >= 0) {\n            var r, s;\n            var b = core.getbit(f, n);\n            r = core.sum(aq[0][0], aq[0][1], aq[1][0], aq[1][1], x_1);\n            s = core.dbl(aq[1 - b][0], aq[1 - b][1]);\n            aq[1 - b] = s;\n            aq[b] = r;\n            n--;\n        }\n        q = aq[1];\n\n        q[1] = core.invmodp(q[1]);\n        q[0] = core.mulmodp(q[0], q[1]);\n        core.reduce(q[0]);\n        return q[0];\n    }\n\n    function curve25519b32(a, b) {\n        return _base32encode(curve25519(_base32decode(a),\n                                        _base32decode(b)));\n    }\n\n    function curve25519(f, c) {\n        if (!c) {\n            c = core.BASE();\n        }\n        f[0] &= 0xFFF8;\n        f[15] = (f[15] & 0x7FFF) | 0x4000;\n        return curve25519_raw(f, c);\n    }\n\n    function _hexEncodeVector(k) {\n        var hexKey = utils.hexEncode(k);\n        // Pad with '0' at the front.\n        hexKey = new Array(64 + 1 - hexKey.length).join('0') + hexKey;\n        // Invert bytes.\n        return hexKey.split(/(..)/).reverse().join('');\n    }\n\n    function _hexDecodeVector(v) {\n        // assert(length(x) == 64);\n        // Invert bytes.\n        var hexKey = v.split(/(..)/).reverse().join('');\n        return utils.hexDecode(hexKey);\n    }\n\n\n    // Expose some functions to the outside through this name space.\n\n    /**\n     * Computes the scalar product of a point on the curve 25519.\n     *\n     * This function is used for the DH key-exchange protocol.\n     *\n     * Before multiplication, some bit operations are applied to the\n     * private key to ensure it is a valid Curve25519 secret key.\n     * It is the user's responsibility to make sure that the private\n     * key is a uniformly random, secret value.\n     *\n     * @function\n     * @param f {array}\n     *     Private key.\n     * @param c {array}\n     *     Public point on the curve. If not given, the curve's base point is used.\n     * @returns {array}\n     *     Key point resulting from scalar product.\n     */\n    ns.curve25519 = curve25519;\n\n    /**\n     * Computes the scalar product of a point on the curve 25519.\n     *\n     * This variant does not make sure that the private key is valid.\n     * The user has the responsibility to ensure the private key is\n     * valid or that this results in a safe protocol.  Unless you know\n     * exactly what you are doing, you should not use this variant,\n     * please use 'curve25519' instead.\n     *\n     * @function\n     * @param f {array}\n     *     Private key.\n     * @param c {array}\n     *     Public point on the curve. If not given, the curve's base point is used.\n     * @returns {array}\n     *     Key point resulting from scalar product.\n     */\n    ns.curve25519_raw = curve25519_raw;\n\n    /**\n     * Encodes the internal representation of a key to a canonical hex\n     * representation.\n     *\n     * This is the format commonly used in other libraries and for\n     * test vectors, and is equivalent to the hex dump of the key in\n     * little-endian binary format.\n     *\n     * @function\n     * @param n {array}\n     *     Array representation of key.\n     * @returns {string}\n     *     Hexadecimal string representation of key.\n     */\n    ns.hexEncodeVector = _hexEncodeVector;\n\n    /**\n     * Decodes a canonical hex representation of a key\n     * to an internally compatible array representation.\n     *\n     * @function\n     * @param n {string}\n     *     Hexadecimal string representation of key.\n     * @returns {array}\n     *     Array representation of key.\n     */\n    ns.hexDecodeVector = _hexDecodeVector;\n\n    /**\n     * Encodes the internal representation of a key into a\n     * hexadecimal representation.\n     *\n     * This is a strict positional notation, most significant digit first.\n     *\n     * @function\n     * @param n {array}\n     *     Array representation of key.\n     * @returns {string}\n     *     Hexadecimal string representation of key.\n     */\n    ns.hexencode = utils.hexEncode;\n\n    /**\n     * Decodes a hex representation of a key to an internally\n     * compatible array representation.\n     *\n     * @function\n     * @param n {string}\n     *     Hexadecimal string representation of key.\n     * @returns {array}\n     *     Array representation of key.\n     */\n    ns.hexdecode = utils.hexDecode;\n\n    /**\n     * Encodes the internal representation of a key to a base32\n     * representation.\n     *\n     * @function\n     * @param n {array}\n     *     Array representation of key.\n     * @returns {string}\n     *     Base32 string representation of key.\n     */\n    ns.base32encode = utils.base32encode;\n\n    /**\n     * Decodes a base32 representation of a key to an internally\n     * compatible array representation.\n     *\n     * @function\n     * @param n {string}\n     *     Base32 string representation of key.\n     * @returns {array}\n     *     Array representation of key.\n     */\n    ns.base32decode = utils.base32decode;\n\nmodule.exports = ns;\n"]}