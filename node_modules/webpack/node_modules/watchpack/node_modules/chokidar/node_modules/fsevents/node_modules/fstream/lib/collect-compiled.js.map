{"version":3,"sources":["collect.js"],"names":[],"mappings":"AAAA,OAAO,OAAP,GAAiB,OAAjB;;AAEA,SAAS,OAAT,CAAkB,MAAlB,EAA0B;AACxB,MAAI,OAAO,UAAX,EAAuB;;AAEvB,SAAO,UAAP,GAAoB,IAApB;AACA,SAAO,KAAP;;AAEA,SAAO,EAAP,CAAU,MAAV,EAAkB,IAAlB;AACA,SAAO,EAAP,CAAU,KAAV,EAAiB,IAAjB;AACA,MAAI,MAAM,EAAV;AACA,WAAS,IAAT,CAAe,CAAf,EAAkB;AAChB,QAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B,IAAI,IAAI,MAAJ,CAAW,CAAX,CAAJ;AAC3B,QAAI,OAAO,QAAP,CAAgB,CAAhB,KAAsB,CAAC,EAAE,MAA7B,EAAqC;AACrC,QAAI,IAAJ,CAAS,CAAT;AACD;;AAED,SAAO,EAAP,CAAU,OAAV,EAAmB,SAAnB;AACA,MAAI,cAAc,EAAlB;AACA,WAAS,SAAT,CAAoB,CAApB,EAAuB;AACrB,YAAQ,CAAR;AACA,gBAAY,IAAZ,CAAiB,CAAjB;AACD;;AAED,SAAO,EAAP,CAAU,OAAV,EAAmB,UAAnB;AACA,WAAS,UAAT,CAAqB,CAArB,EAAwB;AACtB,MAAE,KAAF;AACD;;;;;AAKD,SAAO,IAAP,GAAe,UAAU,IAAV,EAAgB;AAC7B,WAAO,UAAU,IAAV,EAAgB;;;;;AAKrB,UAAI,IAAI,CAAR,CACC,CAAC,SAAS,YAAT,GAAyB;AACzB,YAAI,QAAQ,YAAY,GAAZ,CAAZ;;AAEA,YAAI,CAAC,KAAL,EAAY,OAAO,QAAP;AACZ,cAAM,EAAN,CAAS,KAAT,EAAgB,YAAhB;AACA,YAAI,IAAJ,EAAU,KAAK,GAAL,CAAS,KAAT,EAAV,KACK,OAAO,IAAP,CAAY,OAAZ,EAAqB,KAArB;AACN,OAPA;;AASD,eAAS,MAAT,GAAmB;AACjB,eAAO,cAAP,CAAsB,OAAtB,EAA+B,SAA/B;AACA,eAAO,cAAP,CAAsB,MAAtB,EAA8B,IAA9B;AACA,eAAO,cAAP,CAAsB,KAAtB,EAA6B,IAA7B;;AAEA,eAAO,IAAP,GAAc,IAAd;AACA,YAAI,IAAJ,EAAU,OAAO,IAAP,CAAY,IAAZ;;AAEV,YAAI,OAAJ,CAAY,UAAU,CAAV,EAAa;AACvB,cAAI,CAAJ,EAAO,OAAO,IAAP,CAAY,MAAZ,EAAoB,CAApB,EAAP,KACK,OAAO,IAAP,CAAY,KAAZ;AACN,SAHD;;AAKA,eAAO,MAAP;AACD;;AAED,aAAO,IAAP;AACD,KAhCD;AAiCD,GAlCa,CAkCX,OAAO,IAlCI,CAAd;AAmCD","file":"collect-compiled.js","sourcesContent":["module.exports = collect\n\nfunction collect (stream) {\n  if (stream._collected) return\n\n  stream._collected = true\n  stream.pause()\n\n  stream.on('data', save)\n  stream.on('end', save)\n  var buf = []\n  function save (b) {\n    if (typeof b === 'string') b = new Buffer(b)\n    if (Buffer.isBuffer(b) && !b.length) return\n    buf.push(b)\n  }\n\n  stream.on('entry', saveEntry)\n  var entryBuffer = []\n  function saveEntry (e) {\n    collect(e)\n    entryBuffer.push(e)\n  }\n\n  stream.on('proxy', proxyPause)\n  function proxyPause (p) {\n    p.pause()\n  }\n\n  // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n  stream.pipe = (function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0\n      ;(function unblockEntry () {\n        var entry = entryBuffer[e++]\n        // console.error(\" ==== unblock entry\", entry && entry.path)\n        if (!entry) return resume()\n        entry.on('end', unblockEntry)\n        if (dest) dest.add(entry)\n        else stream.emit('entry', entry)\n      })()\n\n      function resume () {\n        stream.removeListener('entry', saveEntry)\n        stream.removeListener('data', save)\n        stream.removeListener('end', save)\n\n        stream.pipe = orig\n        if (dest) stream.pipe(dest)\n\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b)\n          else stream.emit('end')\n        })\n\n        stream.resume()\n      }\n\n      return dest\n    }\n  })(stream.pipe)\n}\n"]}