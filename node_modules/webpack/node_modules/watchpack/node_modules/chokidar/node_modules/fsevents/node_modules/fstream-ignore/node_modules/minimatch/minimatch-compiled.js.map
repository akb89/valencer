{"version":3,"sources":["minimatch.js"],"names":[],"mappings":"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","file":"minimatch-compiled.js","sourcesContent":["module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = require('path')\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new Error('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var plType\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        plType = stateChar\n        patternListStack.push({\n          type: plType,\n          start: i - 1,\n          reStart: re.length\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        re += ')'\n        var pl = patternListStack.pop()\n        plType = pl.type\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        switch (plType) {\n          case '!':\n            negativeLists.push(pl)\n            re += ')[^/]*?)'\n            pl.reEnd = re.length\n            break\n          case '?':\n          case '+':\n          case '*':\n            re += plType\n            break\n          case '@': break // the default anyway\n        }\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + 3)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  var regExp = new RegExp('^' + re + '$', flags)\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n"]}