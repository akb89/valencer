{"version":3,"sources":["streams.js"],"names":[],"mappings":"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","file":"streams-compiled.js","sourcesContent":["'use strict';\n\n/**\n\nStreams in a WebSocket connection\n---------------------------------\n\nWe model a WebSocket as two duplex streams: one stream is for the wire protocol\nover an I/O socket, and the other is for incoming/outgoing messages.\n\n\n                        +----------+      +---------+      +----------+\n    [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]\n                        |          |      +----+----+      |          |\n                        |          |           |           |          |\n                        |    IO    |           | [5]       | Messages |\n                        |          |           V           |          |\n                        |          |      +---------+      |          |\n    [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]\n                        +----------+      +---------+      +----------+\n\n\nMessage transfer in each direction is simple: IO receives a byte stream [1] and\nsends this stream for parsing. The parser will periodically emit a complete\nmessage text on the Messages stream [2]. Similarly, when messages are written\nto the Messages stream [3], they are framed using the WebSocket wire format and\nemitted via IO [4].\n\nThere is a feedback loop via [5] since some input from [1] will be things like\nping, pong and close frames. In these cases the protocol responds by emitting\nresponses directly back to [4] rather than emitting messages via [2].\n\nFor the purposes of flow control, we consider the sources of each Readable\nstream to be as follows:\n\n* [2] receives input from [1]\n* [4] receives input from [1] and [3]\n\nThe classes below express the relationships described above without prescribing\nanything about how parse() and frame() work, other than assuming they emit\n'data' events to the IO and Messages streams. They will work with any protocol\ndriver having these two methods.\n**/\n\n\nvar Stream = require('stream').Stream,\n    util   = require('util');\n\n\nvar IO = function(driver) {\n  this.readable = this.writable = true;\n  this._paused  = false;\n  this._driver  = driver;\n};\nutil.inherits(IO, Stream);\n\n// The IO pause() and resume() methods will be called when the socket we are\n// piping to gets backed up and drains. Since IO output [4] comes from IO input\n// [1] and Messages input [3], we need to tell both of those to return false\n// from write() when this stream is paused.\n\nIO.prototype.pause = function() {\n  this._paused = true;\n  this._driver.messages._paused = true;\n};\n\nIO.prototype.resume = function() {\n  this._paused = false;\n  this.emit('drain');\n\n  var messages = this._driver.messages;\n  messages._paused = false;\n  messages.emit('drain');\n};\n\n// When we receive input from a socket, send it to the parser and tell the\n// source whether to back off.\nIO.prototype.write = function(chunk) {\n  if (!this.writable) return false;\n  this._driver.parse(chunk);\n  return !this._paused;\n};\n\n// The IO end() method will be called when the socket piping into it emits\n// 'close' or 'end', i.e. the socket is closed. In this situation the Messages\n// stream will not emit any more data so we emit 'end'.\nIO.prototype.end = function(chunk) {\n  if (!this.writable) return;\n  if (chunk !== undefined) this.write(chunk);\n  this.writable = false;\n\n  var messages = this._driver.messages;\n  if (messages.readable) {\n    messages.readable = messages.writable = false;\n    messages.emit('end');\n  }\n};\n\nIO.prototype.destroy = function() {\n  this.end();\n};\n\n\nvar Messages = function(driver) {\n  this.readable = this.writable = true;\n  this._paused  = false;\n  this._driver  = driver;\n};\nutil.inherits(Messages, Stream);\n\n// The Messages pause() and resume() methods will be called when the app that's\n// processing the messages gets backed up and drains. If we're emitting\n// messages too fast we should tell the source to slow down. Message output [2]\n// comes from IO input [1].\n\nMessages.prototype.pause = function() {\n  this._driver.io._paused = true;\n};\n\nMessages.prototype.resume = function() {\n  this._driver.io._paused = false;\n  this._driver.io.emit('drain');\n};\n\n// When we receive messages from the user, send them to the formatter and tell\n// the source whether to back off.\nMessages.prototype.write = function(message) {\n  if (!this.writable) return false;\n  if (typeof message === 'string') this._driver.text(message);\n  else this._driver.binary(message);\n  return !this._paused;\n};\n\n// The Messages end() method will be called when a stream piping into it emits\n// 'end'. Many streams may be piped into the WebSocket and one of them ending\n// does not mean the whole socket is done, so just process the input and move\n// on leaving the socket open.\nMessages.prototype.end = function(message) {\n  if (message !== undefined) this.write(message);\n};\n\nMessages.prototype.destroy = function() {};\n\n\nexports.IO = IO;\nexports.Messages = Messages;\n"]}